;**************************************************
; GESTFILE.ASM                                    *
;************************************************** 

.286

INCLUDE DESCRIPT.STR    
INCLUDE CONST.INC
INCLUDE GESTFILE.PUB

SegNoyau SEGMENT BYTE PUBLIC 'CODE'
	ASSUME	CS:SegNoyau

; *********************************************
; Initialise une liste vide
; *********************************************
InitVide PROC NEAR

	PUSHF
	CLI

	MOV [SI].precFPrio, SI ; [SI].precFPrio : adressage indirect par registre : SI = offset, dans DS
						   ; par défaut

	MOV [SI].suivFPrio, SI
	MOV [SI].suivFDP, SI
	MOV [SI].suivFDP, SI

	MOV [SI].priorite, 0

	POPF
	
	RET

InitVide ENDP

; *********************************************
; ZF = 1 si la liste pointée par DS:SI est vide
; ZF = 0 sinon
; *********************************************
FileVide PROC NEAR

	SiLV_: 	CMP [SI].precFPrio, SI	; Si [SI].precFPrio = SI Alors ZF = 1, la liste est considérée
			JNE SinonLV_				; comme vide, on vérifie si c'est vrai pour [SI].precFDP	
			JMP FsiLV_

	SinonLV_ :	CMP [SI].precFDP, SI

	FsiLV_:
	
	RET

FileVide ENDP

; ******************************************************
; Réalise l'insertion d'une cellule dans la QE
; DS:SI pointe sur la cellule qui suivra celle à insérer
; ******************************************************
InsereItemFPrio PROC NEAR

	MOV DI, [SI].precFPrio

	MOV [DI].suivFPrio, BX
	MOV [SI].precFPrio, BX

	MOV [BX].precFPrio, DI
	MOV [BX].suivFPrio, SI
	
	RET

InsereItemFPrio ENDP

; ******************************************************
; Réalise l'insertion d'une cellule dans la FDP
; DS:SI pointe sur la cellule qui suivra celle à insérer
; ******************************************************
InsereItemFDP PROC NEAR

	MOV DI, [SI].precFDP

	MOV [DI].suivFDP, BX
	MOV [SI].precFDP, BX

	MOV [BX].precFDP, DI
	MOV [BX].suivFDP, SI
	
	RET

InsereItemFDP ENDP

; ************************************************
; Réalise l'insertion d'une cellule
; DS:BX pointe sur la cellule à insérer
; DS:SI pointe sur la cellule de garde de la liste
; ************************************************
Insere PROC NEAR

	PUSHA
	PUSHF
	CLI

	SiI_:	CMP [SI].Identite, IdCGQueueExp	; On vérifie si on pointe sur la queue d'exploitation
			JNE SinonI_

	; On cherche à insérer dans la QE
	AlorsI_: 
			CALL Recherche
			CALL InsereItemFPrio
			JMP FsiI_

	SinonI_:	CMP [SI].Identite, IdCGFileDesProc ; Sinon on vérifie qu'on pointe sur les descripteurs
			JNE FsiI_

			CALL Recherche
			CALL InsereItemFDP

	FsiI_:

	POPF
	POPA
	
	RET

Insere ENDP

; ******************************************************
; Détermine la position d'insertion d'un élément
; DS:SI pointe sur la cellule qui suivra celle à insérer
; ******************************************************
Recherche PROC NEAR

	; /!\ ***********************
	; Par prudence !
	PUSHF
	CLI

	SiR_:	CMP [SI].Identite, IdCGQueueExp	; On vérifie si on pointe sur la queue d'exploitation
			JNE SinonR_

	; On cherche à insérer dans la QE
	AlorsR_: MOV SI, [SI].suivFPrio

			CALL FileVide
			JE FsiR_

			TqR_: 	MOV AH, [BX].priorite
					CMP [SI].priorite, AH
					JAE FtqR_

					MOV SI, [SI].suivFPrio

					CMP [SI].Identite, IdCGQueueExp
					JE FsiR_

					JMP TqR_
			FtqR_:

			JMP FsiR_

	SinonR_:	CMP [SI].Identite, IdCGFileDesProc ; Sinon on vérifie qu'on pointe sur les descripteurs
			JE FsiR_

			; On ne fait rien, on pointe déjà sur la cellule de garde

	FsiR_:

	POPF
	
	RET

Recherche ENDP

; **************************************
; Réalise l'extraction d'une cellule
; DS:SI pointe sur la cellule de garde
; DS:BX pointe sur la cellule à extraire
; **************************************
Extrait PROC NEAR

	PUSHA
	PUSHF
	CLI

	SiE_:	CMP [SI].Identite, IdCGQueueExp	; On vérifie si on pointe sur la queue d'exploitation
			JNE SinonE_

	; On cherche à extraire de la QE
	AlorsE_: 		
			CALL FileVide
			JE FsiE_

			MOV DI, [BX].precFPrio ; Stockage de la cellule précédente
			MOV AX, [BX].suivFPrio
			MOV [DI].suivFPrio, AX ; MaJ du chainage

			MOV DI, [BX].suivFPrio
			MOV AX, [BX].precFPrio
			MOV [DI].precFPrio, AX ; MaJ du chainage

			JMP FsiE_

	SinonE_:	CMP [SI].Identite, IdCGFileDesProc ; Sinon on vérifie qu'on pointe sur les descripteurs
			JNE FsiE_

			CALL FileVide
			JE FsiE_

			MOV DI, [BX].precFDP ; Stockage de la cellule précédente
			MOV AX, [BX].suivFDP
			MOV [DI].suivFDP, AX ; MaJ du chainage

			MOV DI, [BX].suivFDP ; Stockage de la cellule suivante
			MOV AX, [BX].precFDP
			MOV [DI].precFDP, AX ; MaJ du chainage

	FsiE_:

	POPF
	POPA
	
	RET

Extrait ENDP

;**************************************************************
;* Procedure PremierDeFile de type NEAR 		     *
;* Entrée DS:SI pointe sur la cellule de garde de la liste    *
;* Resultat BX = 0FFFFh si la liste est vide                  *
;*          BX != 0FFFFh DS:BX pointe sur la cellule extraite *                                          
;**************************************************************

PremierDeFile PROC NEAR

  pusha
  pushf
  cli

  ; Test si la liste est vide 

  CALL FileVide
  JZ ListeEstVide     ; Si liste vide on passe directement à la fin de la fonction special pour liste vide

  ;Test si FPrio ou FDP

  CMP [SI].identite, IdCGQueueExp      ; grace à la fonction EQU defini auparamant Q = IdCGQueuExp et F = IdCGFileDesProc
  JNE FDP

  QE:
    MOV BX, [SI].SuivFPrio ; Case suivante de la cellule de garde i.e cellule à extraire  

    MOV DI, [BX].SuivFPrio
    MOV [SI].SuivFPrio, DI ; le nouveau suivant de la tete de liste est le suivant de la premiere cellule
    MOV [DI].precFPrio, SI

    JMP Fin

  FDP:
    MOV BX, [SI].SuivFDP ; Case suivante de la cellule de garde i.e cellule à extraire

    MOV DI, [BX].SuivFDP
    MOV [SI].SuivFDP, DI ; le nouveau suivant de la tete de liste est le suivant de la premiere cellule
    MOV [DI].precFDP, SI

    JMP Fin

  listeEstVide:
    MOV BX, 0FFFFh

  Fin:
    popf
    popa
    RET

PremierDeFile ENDP


SegNoyau ENDS    ;Fin du segment

END              ;Fin du fichier 
